-- File generated by the BNF Converter (bnfc 2.9.4).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module InterpLatteMalinowe where


import qualified Data.Map as Map
import Control.Monad.Reader
import Control.Monad.State
import Prelude
import AbsLatteMalinowe
import UtilsLatteMalinowe

type IdentEnv = Map.Map Ident Val

type Err = Either String
type Result = Err (Maybe Val)

-- type ContexedExecutor = ReaderT Context

-- zadanie 1
-- z wykorzystaniem monady writer napisz program, który dla każdej topdef
-- dopisuje "funkcja" jako kolejny element listy będącej środowiskiem
-- a na koniec wypisuje środowisko skontatenowane znakiem nowej linii

interpret :: Show a => Program' a -> Result
interpret = transProgram

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

-- transIdent :: AbsLatteMalinowe.Ident -> Result
-- transIdent x = case x of
--   AbsLatteMalinowe.Ident string -> failure x

-- state powinien przechowywać dotychczasowe wyjście
-- oraz mapę dotychczasowych deklaracji

transProgram :: Show a => Program' a -> Result
transProgram x = case x of
  AbsLatteMalinowe.Program _ topdefs -> Right Nothing

transTopDef :: Show a => AbsLatteMalinowe.TopDef' a -> Result
transTopDef x = case x of
  AbsLatteMalinowe.FnDef _ type_ ident args block -> failure x

transArg :: Show a => AbsLatteMalinowe.Arg' a -> Result
transArg x = case x of
  AbsLatteMalinowe.Arg _ type_ ident -> failure x

transBlock :: Show a => AbsLatteMalinowe.Block' a -> Result
transBlock x = case x of
  AbsLatteMalinowe.Block _ stmts -> failure x

execBlock :: Block' a -> IO ()
execBlock b = print $ execState (execBlockM b) Map.empty

execBlockM :: Block' a -> State IdentEnv ()
execBlockM (Block _ stmts) = processSeq execStmtM stmts

execStmtM :: Stmt' a -> State IdentEnv ()
execStmtM s = case s of
  OrdStmt _ os -> case os of 
    Decl _ type_ items -> declManyVarM type_ items
    _ -> return ()
  _ -> return ()

declManyVarM :: Type' a -> [Item' a] -> State IdentEnv ()
declManyVarM type_ items = processSeq (declOneVarM type_) items

declOneVarM :: Type' a -> Item' a -> State IdentEnv ()
declOneVarM type_ item =
  modify $ Map.insert (identItem item) (valueItem type_ item)

transStmt :: Show a => AbsLatteMalinowe.Stmt' a -> Result
transStmt x = case x of
  AbsLatteMalinowe.BStmt _ block -> failure x
  AbsLatteMalinowe.Cond _ expr block -> failure x
  AbsLatteMalinowe.CondElse _ expr block1 block2 -> failure x
  AbsLatteMalinowe.OrdStmt _ ordstmt -> failure x

transOrdStmt :: Show a => AbsLatteMalinowe.OrdStmt' a -> Result
transOrdStmt x = case x of
  AbsLatteMalinowe.While _ expr lblock -> failure x
  AbsLatteMalinowe.For _ ident expr1 expr2 lblock -> failure x
  AbsLatteMalinowe.Empty _ -> failure x
  AbsLatteMalinowe.Decl _ type_ items -> failure x
  AbsLatteMalinowe.Ass _ ident expr -> failure x
  AbsLatteMalinowe.Incr _ ident -> failure x
  AbsLatteMalinowe.Decr _ ident -> failure x
  AbsLatteMalinowe.Ret _ expr -> failure x
  AbsLatteMalinowe.VRet _ -> failure x
  AbsLatteMalinowe.Print _ expr -> failure x
  AbsLatteMalinowe.SExp _ expr -> failure x

transItem :: Show a => AbsLatteMalinowe.Item' a -> Result
transItem x = case x of
  AbsLatteMalinowe.NoInit _ ident -> failure x
  AbsLatteMalinowe.Init _ ident expr -> failure x

transLBlock :: Show a => AbsLatteMalinowe.LBlock' a -> Result
transLBlock x = case x of
  AbsLatteMalinowe.LBlock _ lstmts -> failure x

transLStmt :: Show a => AbsLatteMalinowe.LStmt' a -> Result
transLStmt x = case x of
  AbsLatteMalinowe.LOrdStmt _ ordstmt -> failure x
  AbsLatteMalinowe.LBStmt _ lblock -> failure x
  AbsLatteMalinowe.LCond _ expr lblock -> failure x
  AbsLatteMalinowe.LCondElse _ expr lblock1 lblock2 -> failure x
  AbsLatteMalinowe.LBreak _ -> failure x
  AbsLatteMalinowe.LContinue _ -> failure x

transType :: Show a => AbsLatteMalinowe.Type' a -> Result
transType x = case x of
  AbsLatteMalinowe.Int _ -> failure x
  AbsLatteMalinowe.Str _ -> failure x
  AbsLatteMalinowe.Bool _ -> failure x
  AbsLatteMalinowe.Void _ -> failure x

transExpr :: Show a => AbsLatteMalinowe.Expr' a -> Result
transExpr x = case x of
  AbsLatteMalinowe.EVar _ ident -> failure x
  AbsLatteMalinowe.ELitInt _ integer -> failure x
  AbsLatteMalinowe.ELitTrue _ -> failure x
  AbsLatteMalinowe.ELitFalse _ -> failure x
  AbsLatteMalinowe.EApp _ ident exprs -> failure x
  AbsLatteMalinowe.EString _ string -> failure x
  AbsLatteMalinowe.Neg _ expr -> failure x
  AbsLatteMalinowe.Not _ expr -> failure x
  AbsLatteMalinowe.EMul _ expr1 mulop expr2 -> failure x
  AbsLatteMalinowe.EAdd _ expr1 addop expr2 -> failure x
  AbsLatteMalinowe.ERel _ expr1 relop expr2 -> failure x
  AbsLatteMalinowe.EAnd _ expr1 expr2 -> failure x
  AbsLatteMalinowe.EOr _ expr1 expr2 -> failure x

transAddOp :: Show a => AbsLatteMalinowe.AddOp' a -> Result
transAddOp x = case x of
  AbsLatteMalinowe.Plus _ -> failure x
  AbsLatteMalinowe.Minus _ -> failure x

transMulOp :: Show a => AbsLatteMalinowe.MulOp' a -> Result
transMulOp x = case x of
  AbsLatteMalinowe.Times _ -> failure x
  AbsLatteMalinowe.Div _ -> failure x
  AbsLatteMalinowe.Mod _ -> failure x

transRelOp :: Show a => AbsLatteMalinowe.RelOp' a -> Result
transRelOp x = case x of
  AbsLatteMalinowe.LTH _ -> failure x
  AbsLatteMalinowe.LE _ -> failure x
  AbsLatteMalinowe.GTH _ -> failure x
  AbsLatteMalinowe.GE _ -> failure x
  AbsLatteMalinowe.EQU _ -> failure x
  AbsLatteMalinowe.NE _ -> failure x
